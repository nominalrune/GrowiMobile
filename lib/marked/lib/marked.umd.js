/**
 * marked v14.1.0 - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || from || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    /**
     * Gets the original marked default options.
     */
    function _getDefaults() {
        return {
            async: false,
            breaks: false,
            extensions: null,
            gfm: true,
            hooks: null,
            pedantic: false,
            renderer: null,
            silent: false,
            tokenizer: null,
            walkTokens: null,
        };
    }
    exports.defaults = _getDefaults();
    function changeDefaults(newDefaults) {
        exports.defaults = newDefaults;
    }

    /**
     * Helpers
     */
    var escapeTest = /[&<>"']/;
    var escapeReplace = new RegExp(escapeTest.source, 'g');
    var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
    var escapeReplacements = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
    };
    var getEscapeReplacement = function (ch) { return escapeReplacements[ch]; };
    function escape$1(html, encode) {
        if (encode) {
            if (escapeTest.test(html)) {
                return html.replace(escapeReplace, getEscapeReplacement);
            }
        }
        else {
            if (escapeTestNoEncode.test(html)) {
                return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
            }
        }
        return html;
    }
    var caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
        var source = typeof regex === 'string' ? regex : regex.source;
        opt = opt || '';
        var obj = {
            replace: function (name, val) {
                var valSource = typeof val === 'string' ? val : val.source;
                valSource = valSource.replace(caret, '$1');
                source = source.replace(name, valSource);
                return obj;
            },
            getRegex: function () {
                return new RegExp(source, opt);
            },
        };
        return obj;
    }
    function cleanUrl(href) {
        try {
            href = encodeURI(href).replace(/%25/g, '%');
        }
        catch (_a) {
            return null;
        }
        return href;
    }
    var noopTest = { exec: function () { return null; } };
    function splitCells(tableRow, count) {
        // ensure that every cell-delimiting pipe has a space
        // before it to distinguish it from an escaped pipe
        var row = tableRow.replace(/\|/g, function (match, offset, str) {
            var escaped = false;
            var curr = offset;
            while (--curr >= 0 && str[curr] === '\\')
                escaped = !escaped;
            if (escaped) {
                // odd number of slashes means | is escaped
                // so we leave it alone
                return '|';
            }
            else {
                // add space before unescaped |
                return ' |';
            }
        }), cells = row.split(/ \|/);
        var i = 0;
        // First/last cell in a row cannot be empty if it has no leading/trailing pipe
        if (!cells[0].trim()) {
            cells.shift();
        }
        if (cells.length > 0 && !cells[cells.length - 1].trim()) {
            cells.pop();
        }
        if (count) {
            if (cells.length > count) {
                cells.splice(count);
            }
            else {
                while (cells.length < count)
                    cells.push('');
            }
        }
        for (; i < cells.length; i++) {
            // leading or trailing whitespace is ignored per the gfm spec
            cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }
        return cells;
    }
    /**
     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
     * /c*$/ is vulnerable to REDOS.
     *
     * @param str
     * @param c
     * @param invert Remove suffix of non-c chars instead. Default falsey.
     */
    function rtrim(str, c, invert) {
        var l = str.length;
        if (l === 0) {
            return '';
        }
        // Length of suffix matching the invert condition.
        var suffLen = 0;
        // Step left until we fail to match the invert condition.
        while (suffLen < l) {
            var currChar = str.charAt(l - suffLen - 1);
            if (currChar === c && !invert) {
                suffLen++;
            }
            else if (currChar !== c && invert) {
                suffLen++;
            }
            else {
                break;
            }
        }
        return str.slice(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
        if (str.indexOf(b[1]) === -1) {
            return -1;
        }
        var level = 0;
        for (var i = 0; i < str.length; i++) {
            if (str[i] === '\\') {
                i++;
            }
            else if (str[i] === b[0]) {
                level++;
            }
            else if (str[i] === b[1]) {
                level--;
                if (level < 0) {
                    return i;
                }
            }
        }
        return -1;
    }

    function outputLink(cap, link, raw, lexer) {
        var href = link.href;
        var title = link.title ? escape$1(link.title) : null;
        var text = cap[1].replace(/\\([\[\]])/g, '$1');
        if (cap[0].charAt(0) !== '!') {
            lexer.state.inLink = true;
            var token = {
                type: 'link',
                raw: raw,
                href: href,
                title: title,
                text: text,
                tokens: lexer.inlineTokens(text),
            };
            lexer.state.inLink = false;
            return token;
        }
        return {
            type: 'image',
            raw: raw,
            href: href,
            title: title,
            text: escape$1(text),
        };
    }
    function indentCodeCompensation(raw, text) {
        var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
        if (matchIndentToCode === null) {
            return text;
        }
        var indentToCode = matchIndentToCode[1];
        return text
            .split('\n')
            .map(function (node) {
            var matchIndentInNode = node.match(/^\s+/);
            if (matchIndentInNode === null) {
                return node;
            }
            var indentInNode = matchIndentInNode[0];
            if (indentInNode.length >= indentToCode.length) {
                return node.slice(indentToCode.length);
            }
            return node;
        })
            .join('\n');
    }
    /**
     * Tokenizer
     */
    var _Tokenizer = /** @class */ (function () {
        function _Tokenizer(options) {
            this.options = options || exports.defaults;
        }
        _Tokenizer.prototype.space = function (src) {
            var cap = this.rules.block.newline.exec(src);
            if (cap && cap[0].length > 0) {
                return {
                    type: 'space',
                    raw: cap[0],
                };
            }
        };
        _Tokenizer.prototype.code = function (src) {
            var cap = this.rules.block.code.exec(src);
            if (cap) {
                var text = cap[0].replace(/^ {1,4}/gm, '');
                return {
                    type: 'code',
                    raw: cap[0],
                    codeBlockStyle: 'indented',
                    text: !this.options.pedantic
                        ? rtrim(text, '\n')
                        : text,
                };
            }
        };
        _Tokenizer.prototype.fences = function (src) {
            var cap = this.rules.block.fences.exec(src);
            if (cap) {
                var raw = cap[0];
                var text = indentCodeCompensation(raw, cap[3] || '');
                return {
                    type: 'code',
                    raw: raw,
                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                    text: text,
                };
            }
        };
        _Tokenizer.prototype.heading = function (src) {
            var cap = this.rules.block.heading.exec(src);
            if (cap) {
                var text = cap[2].trim();
                // remove trailing #s
                if (/#$/.test(text)) {
                    var trimmed = rtrim(text, '#');
                    if (this.options.pedantic) {
                        text = trimmed.trim();
                    }
                    else if (!trimmed || / $/.test(trimmed)) {
                        // CommonMark requires space before trailing #s
                        text = trimmed.trim();
                    }
                }
                return {
                    type: 'heading',
                    raw: cap[0],
                    depth: cap[1].length,
                    text: text,
                    tokens: this.lexer.inline(text),
                };
            }
        };
        _Tokenizer.prototype.hr = function (src) {
            var cap = this.rules.block.hr.exec(src);
            if (cap) {
                return {
                    type: 'hr',
                    raw: rtrim(cap[0], '\n'),
                };
            }
        };
        _Tokenizer.prototype.blockquote = function (src) {
            var cap = this.rules.block.blockquote.exec(src);
            if (cap) {
                var lines = rtrim(cap[0], '\n').split('\n');
                var raw = '';
                var text = '';
                var tokens = [];
                while (lines.length > 0) {
                    var inBlockquote = false;
                    var currentLines = [];
                    var i = void 0;
                    for (i = 0; i < lines.length; i++) {
                        // get lines up to a continuation
                        if (/^ {0,3}>/.test(lines[i])) {
                            currentLines.push(lines[i]);
                            inBlockquote = true;
                        }
                        else if (!inBlockquote) {
                            currentLines.push(lines[i]);
                        }
                        else {
                            break;
                        }
                    }
                    lines = lines.slice(i);
                    var currentRaw = currentLines.join('\n');
                    var currentText = currentRaw
                        // precede setext continuation with 4 spaces so it isn't a setext
                        .replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, '\n    $1')
                        .replace(/^ {0,3}>[ \t]?/gm, '');
                    raw = raw ? "".concat(raw, "\n").concat(currentRaw) : currentRaw;
                    text = text ? "".concat(text, "\n").concat(currentText) : currentText;
                    // parse blockquote lines as top level tokens
                    // merge paragraphs if this is a continuation
                    var top_1 = this.lexer.state.top;
                    this.lexer.state.top = true;
                    this.lexer.blockTokens(currentText, tokens, true);
                    this.lexer.state.top = top_1;
                    // if there is no continuation then we are done
                    if (lines.length === 0) {
                        break;
                    }
                    var lastToken = tokens[tokens.length - 1];
                    if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'code') {
                        // blockquote continuation cannot be preceded by a code block
                        break;
                    }
                    else if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'blockquote') {
                        // include continuation in nested blockquote
                        var oldToken = lastToken;
                        var newText = oldToken.raw + '\n' + lines.join('\n');
                        var newToken = this.blockquote(newText);
                        tokens[tokens.length - 1] = newToken;
                        raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
                        text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
                        break;
                    }
                    else if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'list') {
                        // include continuation in nested list
                        var oldToken = lastToken;
                        var newText = oldToken.raw + '\n' + lines.join('\n');
                        var newToken = this.list(newText);
                        tokens[tokens.length - 1] = newToken;
                        raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
                        text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
                        lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\n');
                        continue;
                    }
                }
                return {
                    type: 'blockquote',
                    raw: raw,
                    tokens: tokens,
                    text: text,
                };
            }
        };
        _Tokenizer.prototype.list = function (src) {
            var cap = this.rules.block.list.exec(src);
            if (cap) {
                var bull = cap[1].trim();
                var isordered = bull.length > 1;
                var list = {
                    type: 'list',
                    raw: '',
                    ordered: isordered,
                    start: isordered ? +bull.slice(0, -1) : '',
                    loose: false,
                    items: [],
                };
                bull = isordered ? "\\d{1,9}\\".concat(bull.slice(-1)) : "\\".concat(bull);
                if (this.options.pedantic) {
                    bull = isordered ? bull : '[*+-]';
                }
                // Get next list item
                var itemRegex = new RegExp("^( {0,3}".concat(bull, ")((?:[\t ][^\\n]*)?(?:\\n|$))"));
                var endsWithBlankLine = false;
                // Check if current bullet point can start a new List Item
                while (src) {
                    var endEarly = false;
                    var raw = '';
                    var itemContents = '';
                    if (!(cap = itemRegex.exec(src))) {
                        break;
                    }
                    if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
                        break;
                    }
                    raw = cap[0];
                    src = src.substring(raw.length);
                    var line = cap[2].split('\n', 1)[0].replace(/^\t+/, function (t) { return ' '.repeat(3 * t.length); });
                    var nextLine = src.split('\n', 1)[0];
                    var blankLine = !line.trim();
                    var indent = 0;
                    if (this.options.pedantic) {
                        indent = 2;
                        itemContents = line.trimStart();
                    }
                    else if (blankLine) {
                        indent = cap[1].length + 1;
                    }
                    else {
                        indent = cap[2].search(/[^ ]/); // Find first non-space char
                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                        itemContents = line.slice(indent);
                        indent += cap[1].length;
                    }
                    if (blankLine && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
                        raw += nextLine + '\n';
                        src = src.substring(nextLine.length + 1);
                        endEarly = true;
                    }
                    if (!endEarly) {
                        var nextBulletRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))"));
                        var hrRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"));
                        var fencesBeginRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}(?:```|~~~)"));
                        var headingBeginRegex = new RegExp("^ {0,".concat(Math.min(3, indent - 1), "}#"));
                        // Check if following lines should be included in List Item
                        while (src) {
                            var rawLine = src.split('\n', 1)[0];
                            nextLine = rawLine;
                            // Re-align to follow commonmark nesting rules
                            if (this.options.pedantic) {
                                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                            }
                            // End list item if found code fences
                            if (fencesBeginRegex.test(nextLine)) {
                                break;
                            }
                            // End list item if found start of new heading
                            if (headingBeginRegex.test(nextLine)) {
                                break;
                            }
                            // End list item if found start of new bullet
                            if (nextBulletRegex.test(nextLine)) {
                                break;
                            }
                            // Horizontal rule found
                            if (hrRegex.test(src)) {
                                break;
                            }
                            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible
                                itemContents += '\n' + nextLine.slice(indent);
                            }
                            else {
                                // not enough indentation
                                if (blankLine) {
                                    break;
                                }
                                // paragraph continuation unless last line was a different block level element
                                if (line.search(/[^ ]/) >= 4) { // indented code block
                                    break;
                                }
                                if (fencesBeginRegex.test(line)) {
                                    break;
                                }
                                if (headingBeginRegex.test(line)) {
                                    break;
                                }
                                if (hrRegex.test(line)) {
                                    break;
                                }
                                itemContents += '\n' + nextLine;
                            }
                            if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                                blankLine = true;
                            }
                            raw += rawLine + '\n';
                            src = src.substring(rawLine.length + 1);
                            line = nextLine.slice(indent);
                        }
                    }
                    if (!list.loose) {
                        // If the previous item ended with a blank line, the list is loose
                        if (endsWithBlankLine) {
                            list.loose = true;
                        }
                        else if (/\n *\n *$/.test(raw)) {
                            endsWithBlankLine = true;
                        }
                    }
                    var istask = null;
                    var ischecked = void 0;
                    // Check for task list items
                    if (this.options.gfm) {
                        istask = /^\[[ xX]\] /.exec(itemContents);
                        if (istask) {
                            ischecked = istask[0] !== '[ ] ';
                            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
                        }
                    }
                    list.items.push({
                        type: 'list_item',
                        raw: raw,
                        task: !!istask,
                        checked: ischecked,
                        loose: false,
                        text: itemContents,
                        tokens: [],
                    });
                    list.raw += raw;
                }
                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
                list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();
                list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();
                list.raw = list.raw.trimEnd();
                // Item child tokens handled here at end because we needed to have the final item to trim it first
                for (var i = 0; i < list.items.length; i++) {
                    this.lexer.state.top = false;
                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                    if (!list.loose) {
                        // Check if list should be loose
                        var spacers = list.items[i].tokens.filter(function (t) { return t.type === 'space'; });
                        var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function (t) { return /\n.*\n/.test(t.raw); });
                        list.loose = hasMultipleLineBreaks;
                    }
                }
                // Set all items to loose if list is loose
                if (list.loose) {
                    for (var i = 0; i < list.items.length; i++) {
                        list.items[i].loose = true;
                    }
                }
                return list;
            }
        };
        _Tokenizer.prototype.html = function (src) {
            var cap = this.rules.block.html.exec(src);
            if (cap) {
                var token = {
                    type: 'html',
                    block: true,
                    raw: cap[0],
                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                    text: cap[0],
                };
                return token;
            }
        };
        _Tokenizer.prototype.def = function (src) {
            var cap = this.rules.block.def.exec(src);
            if (cap) {
                var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
                var href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
                var title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
                return {
                    type: 'def',
                    tag: tag,
                    raw: cap[0],
                    href: href,
                    title: title,
                };
            }
        };
        _Tokenizer.prototype.table = function (src) {
            var _this = this;
            var cap = this.rules.block.table.exec(src);
            if (!cap) {
                return;
            }
            if (!/[:|]/.test(cap[2])) {
                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
                return;
            }
            var headers = splitCells(cap[1]);
            var aligns = cap[2].replace(/^\||\| *$/g, '').split('|');
            var rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : [];
            var item = {
                type: 'table',
                raw: cap[0],
                header: [],
                align: [],
                rows: [],
            };
            if (headers.length !== aligns.length) {
                // header and align columns must be equal, rows can be different.
                return;
            }
            for (var _i = 0, aligns_1 = aligns; _i < aligns_1.length; _i++) {
                var align = aligns_1[_i];
                if (/^ *-+: *$/.test(align)) {
                    item.align.push('right');
                }
                else if (/^ *:-+: *$/.test(align)) {
                    item.align.push('center');
                }
                else if (/^ *:-+ *$/.test(align)) {
                    item.align.push('left');
                }
                else {
                    item.align.push(null);
                }
            }
            for (var i = 0; i < headers.length; i++) {
                item.header.push({
                    text: headers[i],
                    tokens: this.lexer.inline(headers[i]),
                    header: true,
                    align: item.align[i],
                });
            }
            for (var _a = 0, rows_1 = rows; _a < rows_1.length; _a++) {
                var row = rows_1[_a];
                item.rows.push(splitCells(row, item.header.length).map(function (cell, i) {
                    return {
                        text: cell,
                        tokens: _this.lexer.inline(cell),
                        header: false,
                        align: item.align[i],
                    };
                }));
            }
            return item;
        };
        _Tokenizer.prototype.lheading = function (src) {
            var cap = this.rules.block.lheading.exec(src);
            if (cap) {
                return {
                    type: 'heading',
                    raw: cap[0],
                    depth: cap[2].charAt(0) === '=' ? 1 : 2,
                    text: cap[1],
                    tokens: this.lexer.inline(cap[1]),
                };
            }
        };
        _Tokenizer.prototype.paragraph = function (src) {
            var cap = this.rules.block.paragraph.exec(src);
            if (cap) {
                var text = cap[1].charAt(cap[1].length - 1) === '\n'
                    ? cap[1].slice(0, -1)
                    : cap[1];
                return {
                    type: 'paragraph',
                    raw: cap[0],
                    text: text,
                    tokens: this.lexer.inline(text),
                };
            }
        };
        _Tokenizer.prototype.text = function (src) {
            var cap = this.rules.block.text.exec(src);
            if (cap) {
                return {
                    type: 'text',
                    raw: cap[0],
                    text: cap[0],
                    tokens: this.lexer.inline(cap[0]),
                };
            }
        };
        _Tokenizer.prototype.escape = function (src) {
            var cap = this.rules.inline.escape.exec(src);
            if (cap) {
                return {
                    type: 'escape',
                    raw: cap[0],
                    text: escape$1(cap[1]),
                };
            }
        };
        _Tokenizer.prototype.tag = function (src) {
            var cap = this.rules.inline.tag.exec(src);
            if (cap) {
                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
                    this.lexer.state.inLink = true;
                }
                else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
                    this.lexer.state.inLink = false;
                }
                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                    this.lexer.state.inRawBlock = true;
                }
                else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                    this.lexer.state.inRawBlock = false;
                }
                return {
                    type: 'html',
                    raw: cap[0],
                    inLink: this.lexer.state.inLink,
                    inRawBlock: this.lexer.state.inRawBlock,
                    block: false,
                    text: cap[0],
                };
            }
        };
        _Tokenizer.prototype.link = function (src) {
            var cap = this.rules.inline.link.exec(src);
            if (cap) {
                var trimmedUrl = cap[2].trim();
                if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                    // commonmark requires matching angle brackets
                    if (!(/>$/.test(trimmedUrl))) {
                        return;
                    }
                    // ending angle bracket cannot be escaped
                    var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                        return;
                    }
                }
                else {
                    // find closing parenthesis
                    var lastParenIndex = findClosingBracket(cap[2], '()');
                    if (lastParenIndex > -1) {
                        var start = cap[0].indexOf('!') === 0 ? 5 : 4;
                        var linkLen = start + cap[1].length + lastParenIndex;
                        cap[2] = cap[2].substring(0, lastParenIndex);
                        cap[0] = cap[0].substring(0, linkLen).trim();
                        cap[3] = '';
                    }
                }
                var href = cap[2];
                var title = '';
                if (this.options.pedantic) {
                    // split pedantic href and title
                    var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                    if (link) {
                        href = link[1];
                        title = link[3];
                    }
                }
                else {
                    title = cap[3] ? cap[3].slice(1, -1) : '';
                }
                href = href.trim();
                if (/^</.test(href)) {
                    if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
                        // pedantic allows starting angle bracket without ending angle bracket
                        href = href.slice(1);
                    }
                    else {
                        href = href.slice(1, -1);
                    }
                }
                return outputLink(cap, {
                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,
                }, cap[0], this.lexer);
            }
        };
        _Tokenizer.prototype.reflink = function (src, links) {
            var cap;
            if ((cap = this.rules.inline.reflink.exec(src))
                || (cap = this.rules.inline.nolink.exec(src))) {
                var linkString = (cap[2] || cap[1]).replace(/\s+/g, ' ');
                var link = links[linkString.toLowerCase()];
                if (!link) {
                    var text = cap[0].charAt(0);
                    return {
                        type: 'text',
                        raw: text,
                        text: text,
                    };
                }
                return outputLink(cap, link, cap[0], this.lexer);
            }
        };
        _Tokenizer.prototype.emStrong = function (src, maskedSrc, prevChar) {
            if (prevChar === void 0) { prevChar = ''; }
            var match = this.rules.inline.emStrongLDelim.exec(src);
            if (!match)
                return;
            // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
            if (match[3] && prevChar.match(/[A-z0-9]/u))
                return;
            var nextChar = match[1] || match[2] || '';
            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
                var lLength = __spreadArray([], match[0], true).length - 1;
                var rDelim = void 0, rLength = void 0, delimTotal = lLength, midDelimTotal = 0;
                var endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
                endReg.lastIndex = 0;
                // Clip maskedSrc to same section of string as src (move to lexer?)
                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
                while ((match = endReg.exec(maskedSrc)) != null) {
                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                    if (!rDelim)
                        continue; // skip single * in __abc*abc__
                    rLength = __spreadArray([], rDelim, true).length;
                    if (match[3] || match[4]) { // found another Left Delim
                        delimTotal += rLength;
                        continue;
                    }
                    else if (match[5] || match[6]) { // either Left or Right Delim
                        if (lLength % 3 && !((lLength + rLength) % 3)) {
                            midDelimTotal += rLength;
                            continue; // CommonMark Emphasis Rules 9-10
                        }
                    }
                    delimTotal -= rLength;
                    if (delimTotal > 0)
                        continue; // Haven't found enough closing delimiters
                    // Remove extra characters. *a*** -> *a*
                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                    // char length can be >1 for unicode characters;
                    var lastCharLength = __spreadArray([], match[0], true)[0].length;
                    var raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                    // Create `em` if smallest delimiter has odd char count. *a***
                    if (Math.min(lLength, rLength) % 2) {
                        var text_1 = raw.slice(1, -1);
                        return {
                            type: 'em',
                            raw: raw,
                            text: text_1,
                            tokens: this.lexer.inlineTokens(text_1),
                        };
                    }
                    // Create 'strong' if smallest delimiter has even char count. **a***
                    var text = raw.slice(2, -2);
                    return {
                        type: 'strong',
                        raw: raw,
                        text: text,
                        tokens: this.lexer.inlineTokens(text),
                    };
                }
            }
        };
        _Tokenizer.prototype.codespan = function (src) {
            var cap = this.rules.inline.code.exec(src);
            if (cap) {
                var text = cap[2].replace(/\n/g, ' ');
                var hasNonSpaceChars = /[^ ]/.test(text);
                var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                    text = text.substring(1, text.length - 1);
                }
                text = escape$1(text, true);
                return {
                    type: 'codespan',
                    raw: cap[0],
                    text: text,
                };
            }
        };
        _Tokenizer.prototype.br = function (src) {
            var cap = this.rules.inline.br.exec(src);
            if (cap) {
                return {
                    type: 'br',
                    raw: cap[0],
                };
            }
        };
        _Tokenizer.prototype.del = function (src) {
            var cap = this.rules.inline.del.exec(src);
            if (cap) {
                return {
                    type: 'del',
                    raw: cap[0],
                    text: cap[2],
                    tokens: this.lexer.inlineTokens(cap[2]),
                };
            }
        };
        _Tokenizer.prototype.autolink = function (src) {
            var cap = this.rules.inline.autolink.exec(src);
            if (cap) {
                var text = void 0, href = void 0;
                if (cap[2] === '@') {
                    text = escape$1(cap[1]);
                    href = 'mailto:' + text;
                }
                else {
                    text = escape$1(cap[1]);
                    href = text;
                }
                return {
                    type: 'link',
                    raw: cap[0],
                    text: text,
                    href: href,
                    tokens: [
                        {
                            type: 'text',
                            raw: text,
                            text: text,
                        },
                    ],
                };
            }
        };
        _Tokenizer.prototype.url = function (src) {
            var _a, _b;
            var cap;
            if (cap = this.rules.inline.url.exec(src)) {
                var text = void 0, href = void 0;
                if (cap[2] === '@') {
                    text = escape$1(cap[0]);
                    href = 'mailto:' + text;
                }
                else {
                    // do extended autolink path validation
                    var prevCapZero = void 0;
                    do {
                        prevCapZero = cap[0];
                        cap[0] = (_b = (_a = this.rules.inline._backpedal.exec(cap[0])) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : '';
                    } while (prevCapZero !== cap[0]);
                    text = escape$1(cap[0]);
                    if (cap[1] === 'www.') {
                        href = 'http://' + cap[0];
                    }
                    else {
                        href = cap[0];
                    }
                }
                return {
                    type: 'link',
                    raw: cap[0],
                    text: text,
                    href: href,
                    tokens: [
                        {
                            type: 'text',
                            raw: text,
                            text: text,
                        },
                    ],
                };
            }
        };
        _Tokenizer.prototype.inlineText = function (src) {
            var cap = this.rules.inline.text.exec(src);
            if (cap) {
                var text = void 0;
                if (this.lexer.state.inRawBlock) {
                    text = cap[0];
                }
                else {
                    text = escape$1(cap[0]);
                }
                return {
                    type: 'text',
                    raw: cap[0],
                    text: text,
                };
            }
        };
        return _Tokenizer;
    }());

    /**
     * Block-Level Grammar
     */
    var newline = /^(?: *(?:\n|$))+/;
    var blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
    var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
    var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
    var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
    var bullet = /(?:[*+-]|\d{1,9}[.)])/;
    var lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/)
        .replace(/bull/g, bullet) // lists can interrupt
        .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt
        .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
        .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
        .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
        .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
        .getRegex();
    var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
    var blockText = /^[^\n]+/;
    var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    var def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
        .replace('label', _blockLabel)
        .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
        .getRegex();
    var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
        .replace(/bull/g, bullet)
        .getRegex();
    var _tag = 'address|article|aside|base|basefont|blockquote|body|caption'
        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
        + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'
        + '|tr|track|ul';
    var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
    var html = edit('^ {0,3}(?:' // optional indentation
        + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
        + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
        + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
        + ')', 'i')
        .replace('comment', _comment)
        .replace('tag', _tag)
        .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
        .getRegex();
    var paragraph = edit(_paragraph)
        .replace('hr', hr)
        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
        .replace('|table', '')
        .replace('blockquote', ' {0,3}>')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
        .getRegex();
    var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
        .replace('paragraph', paragraph)
        .getRegex();
    /**
     * Normal Block Grammar
     */
    var blockNormal = {
        blockquote: blockquote,
        code: blockCode,
        def: def,
        fences: fences,
        heading: heading,
        hr: hr,
        html: html,
        lheading: lheading,
        list: list,
        newline: newline,
        paragraph: paragraph,
        table: noopTest,
        text: blockText,
    };
    /**
     * GFM Block Grammar
     */
    var gfmTable = edit('^ *([^\\n ].*)\\n' // Header
        + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
        + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)') // Cells
        .replace('hr', hr)
        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
        .replace('blockquote', ' {0,3}>')
        .replace('code', ' {4}[^\\n]')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', _tag) // tables can be interrupted by type (6) html blocks
        .getRegex();
    var blockGfm = __assign(__assign({}, blockNormal), { table: gfmTable, paragraph: edit(_paragraph)
            .replace('hr', hr)
            .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
            .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
            .replace('table', gfmTable) // interrupt paragraphs with table
            .replace('blockquote', ' {0,3}>')
            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
            .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
            .getRegex() });
    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */
    var blockPedantic = __assign(__assign({}, blockNormal), { html: edit('^ *(?:comment *(?:\\n|\\s*$)'
            + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
            + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
            .replace('comment', _comment)
            .replace(/tag/g, '(?!(?:'
            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
            + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
            .getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: noopTest, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: edit(_paragraph)
            .replace('hr', hr)
            .replace('heading', ' *#{1,6} *[^\n]')
            .replace('lheading', lheading)
            .replace('|table', '')
            .replace('blockquote', ' {0,3}>')
            .replace('|fences', '')
            .replace('|list', '')
            .replace('|html', '')
            .replace('|tag', '')
            .getRegex() });
    /**
     * Inline-Level Grammar
     */
    var escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
    var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
    var br = /^( {2,}|\\)\n(?!\s*$)/;
    var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
    // list of unicode punctuation marks, plus any missing characters from CommonMark spec
    var _punctuation = ' ,.\t';
    var punctuation = edit(/^((?![*_])[\spunctuation])/, 'u')
        .replace(/punctuation/g, _punctuation).getRegex();
    // sequences em should skip over [title](link), `code`, <html>
    var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, 'u')
        .replace(/punct/g, _punctuation)
        .getRegex();
    var emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' // Skip orphan inside strong
        + '|[^*]+(?=[^*])' // Consume to delim
        + '|(?!\\*)[punct](\\*+)(?=[\\s]|$)' // (1) #*** can only be a Right Delimiter
        + '|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter
        + '|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])' // (3) #***a, ***a can only be Left Delimiter
        + '|[\\s](\\*+)(?!\\*)(?=[punct])' // (4) ***# can only be Left Delimiter
        + '|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter
        + '|[^punct\\s](\\*+)(?=[^punct\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter
        .replace(/punct/g, _punctuation)
        .getRegex();
    // (6) Not allowed for _
    var emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' // Skip orphan inside strong
        + '|[^_]+(?=[^_])' // Consume to delim
        + '|(?!_)[punct](_+)(?=[\\s]|$)' // (1) #___ can only be a Right Delimiter
        + '|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter
        + '|(?!_)[punct\\s](_+)(?=[^punct\\s])' // (3) #___a, ___a can only be Left Delimiter
        + '|[\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter
        + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter
        .replace(/punct/g, _punctuation)
        .getRegex();
    var anyPunctuation = edit(/\\([punct])/, 'gu')
        .replace(/punct/g, _punctuation)
        .getRegex();
    var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
        .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
        .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
        .getRegex();
    var _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
    var tag = edit('^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>') // CDATA section
        .replace('comment', _inlineComment)
        .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
        .getRegex();
    var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
        .replace('label', _inlineLabel)
        .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
        .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
        .getRegex();
    var reflink = edit(/^!?\[(label)\]\[(ref)\]/)
        .replace('label', _inlineLabel)
        .replace('ref', _blockLabel)
        .getRegex();
    var nolink = edit(/^!?\[(ref)\](?:\[\])?/)
        .replace('ref', _blockLabel)
        .getRegex();
    var reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
        .replace('reflink', reflink)
        .replace('nolink', nolink)
        .getRegex();
    /**
     * Normal Inline Grammar
     */
    var inlineNormal = {
        _backpedal: noopTest, // only used for GFM url
        anyPunctuation: anyPunctuation,
        autolink: autolink,
        blockSkip: blockSkip,
        br: br,
        code: inlineCode,
        del: noopTest,
        emStrongLDelim: emStrongLDelim,
        emStrongRDelimAst: emStrongRDelimAst,
        emStrongRDelimUnd: emStrongRDelimUnd,
        escape: escape,
        link: link,
        nolink: nolink,
        punctuation: punctuation,
        reflink: reflink,
        reflinkSearch: reflinkSearch,
        tag: tag,
        text: inlineText,
        url: noopTest,
    };
    /**
     * Pedantic Inline Grammar
     */
    var inlinePedantic = __assign(__assign({}, inlineNormal), { link: edit(/^!?\[(label)\]\((.*?)\)/)
            .replace('label', _inlineLabel)
            .getRegex(), reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
            .replace('label', _inlineLabel)
            .getRegex() });
    /**
     * GFM Inline Grammar
     */
    var inlineGfm = __assign(__assign({}, inlineNormal), { escape: edit(escape).replace('])', '~|])').getRegex(), url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
            .getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ });
    /**
     * GFM + Line Breaks Inline Grammar
     */
    var inlineBreaks = __assign(__assign({}, inlineGfm), { br: edit(br).replace('{2,}', '*').getRegex(), text: edit(inlineGfm.text)
            .replace('\\b_', '\\b_| {2,}\\n')
            .replace(/\{2,\}/g, '*')
            .getRegex() });
    /**
     * exports
     */
    var block = {
        normal: blockNormal,
        gfm: blockGfm,
        pedantic: blockPedantic,
    };
    var inline = {
        normal: inlineNormal,
        gfm: inlineGfm,
        breaks: inlineBreaks,
        pedantic: inlinePedantic,
    };

    /**
     * Block Lexer
     */
    var _Lexer = /** @class */ (function () {
        function _Lexer(options) {
            // TokenList cannot be created in one go
            this.tokens = [];
            this.tokens.links = Object.create(null);
            this.options = options || exports.defaults;
            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
            this.tokenizer = this.options.tokenizer;
            this.tokenizer.options = this.options;
            this.tokenizer.lexer = this;
            this.inlineQueue = [];
            this.state = {
                inLink: false,
                inRawBlock: false,
                top: true,
            };
            var rules = {
                block: block.normal,
                inline: inline.normal,
            };
            if (this.options.pedantic) {
                rules.block = block.pedantic;
                rules.inline = inline.pedantic;
            }
            else if (this.options.gfm) {
                rules.block = block.gfm;
                if (this.options.breaks) {
                    rules.inline = inline.breaks;
                }
                else {
                    rules.inline = inline.gfm;
                }
            }
            this.tokenizer.rules = rules;
        }
        Object.defineProperty(_Lexer, "rules", {
            /**
             * Expose Rules
             */
            get: function () {
                return {
                    block: block,
                    inline: inline,
                };
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Static Lex Method
         */
        _Lexer.lex = function (src, options) {
            var lexer = new _Lexer(options);
            return lexer.lex(src);
        };
        /**
         * Static Lex Inline Method
         */
        _Lexer.lexInline = function (src, options) {
            var lexer = new _Lexer(options);
            return lexer.inlineTokens(src);
        };
        /**
         * Preprocessing
         */
        _Lexer.prototype.lex = function (src) {
            src = src
                .replace(/\r\n|\r/g, '\n');
            this.blockTokens(src, this.tokens);
            for (var i = 0; i < this.inlineQueue.length; i++) {
                var next = this.inlineQueue[i];
                this.inlineTokens(next.src, next.tokens);
            }
            this.inlineQueue = [];
            return this.tokens;
        };
        _Lexer.prototype.blockTokens = function (src, tokens, lastParagraphClipped) {
            var _this = this;
            if (tokens === void 0) { tokens = []; }
            if (lastParagraphClipped === void 0) { lastParagraphClipped = false; }
            if (this.options.pedantic) {
                src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
            }
            else {
                src = src.replace(/^( *)(\t+)/gm, function (_, leading, tabs) {
                    return leading + '    '.repeat(tabs.length);
                });
            }
            var token;
            var lastToken;
            var cutSrc;
            var _loop_1 = function () {
                if (this_1.options.extensions
                    && this_1.options.extensions.block
                    && this_1.options.extensions.block.some(function (extTokenizer) {
                        if (token = extTokenizer.call({ lexer: _this }, src, tokens)) {
                            src = src.substring(token.raw.length);
                            tokens.push(token);
                            return true;
                        }
                        return false;
                    })) {
                    return "continue";
                }
                // newline
                if (token = this_1.tokenizer.space(src)) {
                    src = src.substring(token.raw.length);
                    if (token.raw.length === 1 && tokens.length > 0) {
                        // if there's a single \n as a spacer, it's terminating the last line,
                        // so move it there so that we don't get unnecessary paragraph tags
                        tokens[tokens.length - 1].raw += '\n';
                    }
                    else {
                        tokens.push(token);
                    }
                    return "continue";
                }
                // code
                if (token = this_1.tokenizer.code(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    // An indented code block cannot interrupt a paragraph.
                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.text;
                        this_1.inlineQueue[this_1.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    return "continue";
                }
                // fences
                if (token = this_1.tokenizer.fences(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // heading
                if (token = this_1.tokenizer.heading(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // hr
                if (token = this_1.tokenizer.hr(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // blockquote
                if (token = this_1.tokenizer.blockquote(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // list
                if (token = this_1.tokenizer.list(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // html
                if (token = this_1.tokenizer.html(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // def
                if (token = this_1.tokenizer.def(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.raw;
                        this_1.inlineQueue[this_1.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else if (!this_1.tokens.links[token.tag]) {
                        this_1.tokens.links[token.tag] = {
                            href: token.href,
                            title: token.title,
                        };
                    }
                    return "continue";
                }
                // table (gfm)
                if (token = this_1.tokenizer.table(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // lheading
                if (token = this_1.tokenizer.lheading(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // top-level paragraph
                // prevent paragraph consuming extensions by clipping 'src' to extension start
                cutSrc = src;
                if (this_1.options.extensions && this_1.options.extensions.startBlock) {
                    var startIndex_1 = Infinity;
                    var tempSrc_1 = src.slice(1);
                    var tempStart_1;
                    this_1.options.extensions.startBlock.forEach(function (getStartIndex) {
                        tempStart_1 = getStartIndex.call({ lexer: _this }, tempSrc_1);
                        if (typeof tempStart_1 === 'number' && tempStart_1 >= 0) {
                            startIndex_1 = Math.min(startIndex_1, tempStart_1);
                        }
                    });
                    if (startIndex_1 < Infinity && startIndex_1 >= 0) {
                        cutSrc = src.substring(0, startIndex_1 + 1);
                    }
                }
                if (this_1.state.top && (token = this_1.tokenizer.paragraph(cutSrc))) {
                    lastToken = tokens[tokens.length - 1];
                    if (lastParagraphClipped && (lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'paragraph') {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.text;
                        this_1.inlineQueue.pop();
                        this_1.inlineQueue[this_1.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    lastParagraphClipped = (cutSrc.length !== src.length);
                    src = src.substring(token.raw.length);
                    return "continue";
                }
                // text
                if (token = this_1.tokenizer.text(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && lastToken.type === 'text') {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.text;
                        this_1.inlineQueue.pop();
                        this_1.inlineQueue[this_1.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    return "continue";
                }
                if (src) {
                    var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                    if (this_1.options.silent) {
                        console.error(errMsg);
                        return "break";
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            };
            var this_1 = this;
            while (src) {
                var state_1 = _loop_1();
                if (state_1 === "break")
                    break;
            }
            this.state.top = true;
            return tokens;
        };
        _Lexer.prototype.inline = function (src, tokens) {
            if (tokens === void 0) { tokens = []; }
            this.inlineQueue.push({ src: src, tokens: tokens });
            return tokens;
        };
        /**
         * Lexing/Compiling
         */
        _Lexer.prototype.inlineTokens = function (src, tokens) {
            var _this = this;
            if (tokens === void 0) { tokens = []; }
            var token, lastToken, cutSrc;
            // String with links masked to avoid interference with em and strong
            var maskedSrc = src;
            var match;
            var keepPrevChar, prevChar;
            // Mask out reflinks
            if (this.tokens.links) {
                var links = Object.keys(this.tokens.links);
                if (links.length > 0) {
                    while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                        if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                        }
                    }
                }
            }
            // Mask out other blocks
            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            }
            // Mask out escaped characters
            while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
                maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
            }
            var _loop_2 = function () {
                if (!keepPrevChar) {
                    prevChar = '';
                }
                keepPrevChar = false;
                // extensions
                if (this_2.options.extensions
                    && this_2.options.extensions.inline
                    && this_2.options.extensions.inline.some(function (extTokenizer) {
                        if (token = extTokenizer.call({ lexer: _this }, src, tokens)) {
                            src = src.substring(token.raw.length);
                            tokens.push(token);
                            return true;
                        }
                        return false;
                    })) {
                    return "continue";
                }
                // escape
                if (token = this_2.tokenizer.escape(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // tag
                if (token = this_2.tokenizer.tag(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                        lastToken.raw += token.raw;
                        lastToken.text += token.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    return "continue";
                }
                // link
                if (token = this_2.tokenizer.link(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // reflink, nolink
                if (token = this_2.tokenizer.reflink(src, this_2.tokens.links)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                        lastToken.raw += token.raw;
                        lastToken.text += token.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    return "continue";
                }
                // em & strong
                if (token = this_2.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // code
                if (token = this_2.tokenizer.codespan(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // br
                if (token = this_2.tokenizer.br(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // del (gfm)
                if (token = this_2.tokenizer.del(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // autolink
                if (token = this_2.tokenizer.autolink(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // url (gfm)
                if (!this_2.state.inLink && (token = this_2.tokenizer.url(src))) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return "continue";
                }
                // text
                // prevent inlineText consuming extensions by clipping 'src' to extension start
                cutSrc = src;
                if (this_2.options.extensions && this_2.options.extensions.startInline) {
                    var startIndex_2 = Infinity;
                    var tempSrc_2 = src.slice(1);
                    var tempStart_2;
                    this_2.options.extensions.startInline.forEach(function (getStartIndex) {
                        tempStart_2 = getStartIndex.call({ lexer: _this }, tempSrc_2);
                        if (typeof tempStart_2 === 'number' && tempStart_2 >= 0) {
                            startIndex_2 = Math.min(startIndex_2, tempStart_2);
                        }
                    });
                    if (startIndex_2 < Infinity && startIndex_2 >= 0) {
                        cutSrc = src.substring(0, startIndex_2 + 1);
                    }
                }
                if (token = this_2.tokenizer.inlineText(cutSrc)) {
                    src = src.substring(token.raw.length);
                    if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
                        prevChar = token.raw.slice(-1);
                    }
                    keepPrevChar = true;
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && lastToken.type === 'text') {
                        lastToken.raw += token.raw;
                        lastToken.text += token.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    return "continue";
                }
                if (src) {
                    var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                    if (this_2.options.silent) {
                        console.error(errMsg);
                        return "break";
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            };
            var this_2 = this;
            while (src) {
                var state_2 = _loop_2();
                if (state_2 === "break")
                    break;
            }
            return tokens;
        };
        return _Lexer;
    }());

    /**
     * Renderer
     */
    var _Renderer = /** @class */ (function () {
        function _Renderer(options) {
            this.options = options || exports.defaults;
        }
        _Renderer.prototype.space = function (token) {
            return '';
        };
        _Renderer.prototype.code = function (_a) {
            var _b;
            var text = _a.text, lang = _a.lang, escaped = _a.escaped;
            var langString = (_b = (lang || '').match(/^\S*/)) === null || _b === void 0 ? void 0 : _b[0];
            var code = text.replace(/\n$/, '') + '\n';
            if (!langString) {
                return '<pre><code>'
                    + (escaped ? code : escape$1(code, true))
                    + '</code></pre>\n';
            }
            return '<pre><code class="language-'
                + escape$1(langString)
                + '">'
                + (escaped ? code : escape$1(code, true))
                + '</code></pre>\n';
        };
        _Renderer.prototype.blockquote = function (_a) {
            var tokens = _a.tokens;
            var body = this.parser.parse(tokens);
            return "<blockquote>\n".concat(body, "</blockquote>\n");
        };
        _Renderer.prototype.html = function (_a) {
            var text = _a.text;
            return text;
        };
        _Renderer.prototype.heading = function (_a) {
            var tokens = _a.tokens, depth = _a.depth;
            return "<h".concat(depth, ">").concat(this.parser.parseInline(tokens), "</h").concat(depth, ">\n");
        };
        _Renderer.prototype.hr = function (token) {
            return '<hr>\n';
        };
        _Renderer.prototype.list = function (token) {
            var ordered = token.ordered;
            var start = token.start;
            var body = '';
            for (var j = 0; j < token.items.length; j++) {
                var item = token.items[j];
                body += this.listitem(item);
            }
            var type = ordered ? 'ol' : 'ul';
            var startAttr = (ordered && start !== 1) ? (' start="' + start + '"') : '';
            return '<' + type + startAttr + '>\n' + body + '</' + type + '>\n';
        };
        _Renderer.prototype.listitem = function (item) {
            var itemBody = '';
            if (item.task) {
                var checkbox = this.checkbox({ checked: !!item.checked });
                if (item.loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                        }
                    }
                    else {
                        item.tokens.unshift({
                            type: 'text',
                            raw: checkbox + ' ',
                            text: checkbox + ' ',
                        });
                    }
                }
                else {
                    itemBody += checkbox + ' ';
                }
            }
            itemBody += this.parser.parse(item.tokens, !!item.loose);
            return "<li>".concat(itemBody, "</li>\n");
        };
        _Renderer.prototype.checkbox = function (_a) {
            var checked = _a.checked;
            return '<input '
                + (checked ? 'checked="" ' : '')
                + 'disabled="" type="checkbox">';
        };
        _Renderer.prototype.paragraph = function (_a) {
            var tokens = _a.tokens;
            return "<p>".concat(this.parser.parseInline(tokens), "</p>\n");
        };
        _Renderer.prototype.table = function (token) {
            var header = '';
            // header
            var cell = '';
            for (var j = 0; j < token.header.length; j++) {
                cell += this.tablecell(token.header[j]);
            }
            header += this.tablerow({ text: cell });
            var body = '';
            for (var j = 0; j < token.rows.length; j++) {
                var row = token.rows[j];
                cell = '';
                for (var k = 0; k < row.length; k++) {
                    cell += this.tablecell(row[k]);
                }
                body += this.tablerow({ text: cell });
            }
            if (body)
                body = "<tbody>".concat(body, "</tbody>");
            return '<table>\n'
                + '<thead>\n'
                + header
                + '</thead>\n'
                + body
                + '</table>\n';
        };
        _Renderer.prototype.tablerow = function (_a) {
            var text = _a.text;
            return "<tr>\n".concat(text, "</tr>\n");
        };
        _Renderer.prototype.tablecell = function (token) {
            var content = this.parser.parseInline(token.tokens);
            var type = token.header ? 'th' : 'td';
            var tag = token.align
                ? "<".concat(type, " align=\"").concat(token.align, "\">")
                : "<".concat(type, ">");
            return tag + content + "</".concat(type, ">\n");
        };
        /**
         * span level renderer
         */
        _Renderer.prototype.strong = function (_a) {
            var tokens = _a.tokens;
            return "<strong>".concat(this.parser.parseInline(tokens), "</strong>");
        };
        _Renderer.prototype.em = function (_a) {
            var tokens = _a.tokens;
            return "<em>".concat(this.parser.parseInline(tokens), "</em>");
        };
        _Renderer.prototype.codespan = function (_a) {
            var text = _a.text;
            return "<code>".concat(text, "</code>");
        };
        _Renderer.prototype.br = function (token) {
            return '<br>';
        };
        _Renderer.prototype.del = function (_a) {
            var tokens = _a.tokens;
            return "<del>".concat(this.parser.parseInline(tokens), "</del>");
        };
        _Renderer.prototype.link = function (_a) {
            var href = _a.href, title = _a.title, tokens = _a.tokens;
            var text = this.parser.parseInline(tokens);
            var cleanHref = cleanUrl(href);
            if (cleanHref === null) {
                return text;
            }
            href = cleanHref;
            var out = '<a href="' + href + '"';
            if (title) {
                out += ' title="' + title + '"';
            }
            out += '>' + text + '</a>';
            return out;
        };
        _Renderer.prototype.image = function (_a) {
            var href = _a.href, title = _a.title, text = _a.text;
            var cleanHref = cleanUrl(href);
            if (cleanHref === null) {
                return text;
            }
            href = cleanHref;
            var out = "<img src=\"".concat(href, "\" alt=\"").concat(text, "\"");
            if (title) {
                out += " title=\"".concat(title, "\"");
            }
            out += '>';
            return out;
        };
        _Renderer.prototype.text = function (token) {
            return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;
        };
        return _Renderer;
    }());

    /**
     * TextRenderer
     * returns only the textual part of the token
     */
    var _TextRenderer = /** @class */ (function () {
        function _TextRenderer() {
        }
        // no need for block level renderers
        _TextRenderer.prototype.strong = function (_a) {
            var text = _a.text;
            return text;
        };
        _TextRenderer.prototype.em = function (_a) {
            var text = _a.text;
            return text;
        };
        _TextRenderer.prototype.codespan = function (_a) {
            var text = _a.text;
            return text;
        };
        _TextRenderer.prototype.del = function (_a) {
            var text = _a.text;
            return text;
        };
        _TextRenderer.prototype.html = function (_a) {
            var text = _a.text;
            return text;
        };
        _TextRenderer.prototype.text = function (_a) {
            var text = _a.text;
            return text;
        };
        _TextRenderer.prototype.link = function (_a) {
            var text = _a.text;
            return '' + text;
        };
        _TextRenderer.prototype.image = function (_a) {
            var text = _a.text;
            return '' + text;
        };
        _TextRenderer.prototype.br = function () {
            return '';
        };
        return _TextRenderer;
    }());

    /**
     * Parsing & Compiling
     */
    var _Parser = /** @class */ (function () {
        function _Parser(options) {
            this.options = options || exports.defaults;
            this.options.renderer = this.options.renderer || new _Renderer();
            this.renderer = this.options.renderer;
            this.renderer.options = this.options;
            this.renderer.parser = this;
            this.textRenderer = new _TextRenderer();
        }
        /**
         * Static Parse Method
         */
        _Parser.parse = function (tokens, options) {
            var parser = new _Parser(options);
            return parser.parse(tokens);
        };
        /**
         * Static Parse Inline Method
         */
        _Parser.parseInline = function (tokens, options) {
            var parser = new _Parser(options);
            return parser.parseInline(tokens);
        };
        /**
         * Parse Loop
         */
        _Parser.prototype.parse = function (tokens, top) {
            if (top === void 0) { top = true; }
            var out = '';
            for (var i = 0; i < tokens.length; i++) {
                var anyToken = tokens[i];
                // Run any renderer extensions
                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
                    var genericToken = anyToken;
                    var ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                    if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                        out += ret || '';
                        continue;
                    }
                }
                var token = anyToken;
                switch (token.type) {
                    case 'space': {
                        out += this.renderer.space(token);
                        continue;
                    }
                    case 'hr': {
                        out += this.renderer.hr(token);
                        continue;
                    }
                    case 'heading': {
                        out += this.renderer.heading(token);
                        continue;
                    }
                    case 'code': {
                        out += this.renderer.code(token);
                        continue;
                    }
                    case 'table': {
                        out += this.renderer.table(token);
                        continue;
                    }
                    case 'blockquote': {
                        out += this.renderer.blockquote(token);
                        continue;
                    }
                    case 'list': {
                        out += this.renderer.list(token);
                        continue;
                    }
                    case 'html': {
                        out += this.renderer.html(token);
                        continue;
                    }
                    case 'paragraph': {
                        out += this.renderer.paragraph(token);
                        continue;
                    }
                    case 'text': {
                        var textToken = token;
                        var body = this.renderer.text(textToken);
                        while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                            textToken = tokens[++i];
                            body += '\n' + this.renderer.text(textToken);
                        }
                        if (top) {
                            out += this.renderer.paragraph({
                                type: 'paragraph',
                                raw: body,
                                text: body,
                                tokens: [{ type: 'text', raw: body, text: body }],
                            });
                        }
                        else {
                            out += body;
                        }
                        continue;
                    }
                    default: {
                        var errMsg = 'Token with "' + token.type + '" type was not found.';
                        if (this.options.silent) {
                            console.error(errMsg);
                            return '';
                        }
                        else {
                            throw new Error(errMsg);
                        }
                    }
                }
            }
            return out;
        };
        /**
         * Parse Inline Tokens
         */
        _Parser.prototype.parseInline = function (tokens, renderer) {
            renderer = renderer || this.renderer;
            var out = '';
            for (var i = 0; i < tokens.length; i++) {
                var anyToken = tokens[i];
                // Run any renderer extensions
                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
                    var ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
                    if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {
                        out += ret || '';
                        continue;
                    }
                }
                var token = anyToken;
                switch (token.type) {
                    case 'escape': {
                        out += renderer.text(token);
                        break;
                    }
                    case 'html': {
                        out += renderer.html(token);
                        break;
                    }
                    case 'link': {
                        out += renderer.link(token);
                        break;
                    }
                    case 'image': {
                        out += renderer.image(token);
                        break;
                    }
                    case 'strong': {
                        out += renderer.strong(token);
                        break;
                    }
                    case 'em': {
                        out += renderer.em(token);
                        break;
                    }
                    case 'codespan': {
                        out += renderer.codespan(token);
                        break;
                    }
                    case 'br': {
                        out += renderer.br(token);
                        break;
                    }
                    case 'del': {
                        out += renderer.del(token);
                        break;
                    }
                    case 'text': {
                        out += renderer.text(token);
                        break;
                    }
                    default: {
                        var errMsg = 'Token with "' + token.type + '" type was not found.';
                        if (this.options.silent) {
                            console.error(errMsg);
                            return '';
                        }
                        else {
                            throw new Error(errMsg);
                        }
                    }
                }
            }
            return out;
        };
        return _Parser;
    }());

    var _Hooks = /** @class */ (function () {
        function _Hooks(options) {
            this.options = options || exports.defaults;
        }
        /**
         * Process markdown before marked
         */
        _Hooks.prototype.preprocess = function (markdown) {
            return markdown;
        };
        /**
         * Process HTML after marked is finished
         */
        _Hooks.prototype.postprocess = function (html) {
            return html;
        };
        /**
         * Process all tokens before walk tokens
         */
        _Hooks.prototype.processAllTokens = function (tokens) {
            return tokens;
        };
        /**
         * Provide function to tokenize markdown
         */
        _Hooks.prototype.provideLexer = function () {
            return this.block ? _Lexer.lex : _Lexer.lexInline;
        };
        /**
         * Provide function to parse tokens
         */
        _Hooks.prototype.provideParser = function () {
            return this.block ? _Parser.parse : _Parser.parseInline;
        };
        _Hooks.passThroughHooks = new Set([
            'preprocess',
            'postprocess',
            'processAllTokens',
        ]);
        return _Hooks;
    }());

    var Marked = /** @class */ (function () {
        function Marked() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.defaults = _getDefaults();
            this.options = this.setOptions;
            this.parse = this.parseMarkdown(true);
            this.parseInline = this.parseMarkdown(false);
            this.Parser = _Parser;
            this.Renderer = _Renderer;
            this.TextRenderer = _TextRenderer;
            this.Lexer = _Lexer;
            this.Tokenizer = _Tokenizer;
            this.Hooks = _Hooks;
            this.use.apply(this, args);
        }
        /**
         * Run callback for every token
         */
        Marked.prototype.walkTokens = function (tokens, callback) {
            var _this = this;
            var _a, _b;
            var values = [];
            var _loop_1 = function (token) {
                values = values.concat(callback.call(this_1, token));
                switch (token.type) {
                    case 'table': {
                        var tableToken = token;
                        for (var _c = 0, _d = tableToken.header; _c < _d.length; _c++) {
                            var cell = _d[_c];
                            values = values.concat(this_1.walkTokens(cell.tokens, callback));
                        }
                        for (var _e = 0, _f = tableToken.rows; _e < _f.length; _e++) {
                            var row = _f[_e];
                            for (var _g = 0, row_1 = row; _g < row_1.length; _g++) {
                                var cell = row_1[_g];
                                values = values.concat(this_1.walkTokens(cell.tokens, callback));
                            }
                        }
                        break;
                    }
                    case 'list': {
                        var listToken = token;
                        values = values.concat(this_1.walkTokens(listToken.items, callback));
                        break;
                    }
                    default: {
                        var genericToken_1 = token;
                        if ((_b = (_a = this_1.defaults.extensions) === null || _a === void 0 ? void 0 : _a.childTokens) === null || _b === void 0 ? void 0 : _b[genericToken_1.type]) {
                            this_1.defaults.extensions.childTokens[genericToken_1.type].forEach(function (childTokens) {
                                var tokens = genericToken_1[childTokens].flat(Infinity);
                                values = values.concat(_this.walkTokens(tokens, callback));
                            });
                        }
                        else if (genericToken_1.tokens) {
                            values = values.concat(this_1.walkTokens(genericToken_1.tokens, callback));
                        }
                    }
                }
            };
            var this_1 = this;
            for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
                var token = tokens_1[_i];
                _loop_1(token);
            }
            return values;
        };
        Marked.prototype.use = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
            args.forEach(function (pack) {
                // copy options to new object
                var opts = __assign({}, pack);
                // set async to true if it was set to true before
                opts.async = _this.defaults.async || opts.async || false;
                // ==-- Parse "addon" extensions --== //
                if (pack.extensions) {
                    pack.extensions.forEach(function (ext) {
                        if (!ext.name) {
                            throw new Error('extension name required');
                        }
                        if ('renderer' in ext) { // Renderer extensions
                            var prevRenderer_1 = extensions.renderers[ext.name];
                            if (prevRenderer_1) {
                                // Replace extension with func to run new extension but fall back if false
                                extensions.renderers[ext.name] = function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i] = arguments[_i];
                                    }
                                    var ret = ext.renderer.apply(this, args);
                                    if (ret === false) {
                                        ret = prevRenderer_1.apply(this, args);
                                    }
                                    return ret;
                                };
                            }
                            else {
                                extensions.renderers[ext.name] = ext.renderer;
                            }
                        }
                        if ('tokenizer' in ext) { // Tokenizer Extensions
                            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                                throw new Error("extension level must be 'block' or 'inline'");
                            }
                            var extLevel = extensions[ext.level];
                            if (extLevel) {
                                extLevel.unshift(ext.tokenizer);
                            }
                            else {
                                extensions[ext.level] = [ext.tokenizer];
                            }
                            if (ext.start) { // Function to check for start of token
                                if (ext.level === 'block') {
                                    if (extensions.startBlock) {
                                        extensions.startBlock.push(ext.start);
                                    }
                                    else {
                                        extensions.startBlock = [ext.start];
                                    }
                                }
                                else if (ext.level === 'inline') {
                                    if (extensions.startInline) {
                                        extensions.startInline.push(ext.start);
                                    }
                                    else {
                                        extensions.startInline = [ext.start];
                                    }
                                }
                            }
                        }
                        if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
                            extensions.childTokens[ext.name] = ext.childTokens;
                        }
                    });
                    opts.extensions = extensions;
                }
                // ==-- Parse "overwrite" extensions --== //
                if (pack.renderer) {
                    var renderer_1 = _this.defaults.renderer || new _Renderer(_this.defaults);
                    var _loop_2 = function (prop) {
                        if (!(prop in renderer_1)) {
                            throw new Error("renderer '".concat(prop, "' does not exist"));
                        }
                        if (['options', 'parser'].includes(prop)) {
                            return "continue";
                        }
                        var rendererProp = prop;
                        var rendererFunc = pack.renderer[rendererProp];
                        var prevRenderer = renderer_1[rendererProp];
                        // Replace renderer with func to run extension, but fall back if false
                        renderer_1[rendererProp] = function () {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i] = arguments[_i];
                            }
                            var ret = rendererFunc.apply(renderer_1, args);
                            if (ret === false) {
                                ret = prevRenderer.apply(renderer_1, args);
                            }
                            return ret || '';
                        };
                    };
                    for (var prop in pack.renderer) {
                        _loop_2(prop);
                    }
                    opts.renderer = renderer_1;
                }
                if (pack.tokenizer) {
                    var tokenizer_1 = _this.defaults.tokenizer || new _Tokenizer(_this.defaults);
                    var _loop_3 = function (prop) {
                        if (!(prop in tokenizer_1)) {
                            throw new Error("tokenizer '".concat(prop, "' does not exist"));
                        }
                        if (['options', 'rules', 'lexer'].includes(prop)) {
                            return "continue";
                        }
                        var tokenizerProp = prop;
                        var tokenizerFunc = pack.tokenizer[tokenizerProp];
                        var prevTokenizer = tokenizer_1[tokenizerProp];
                        // Replace tokenizer with func to run extension, but fall back if false
                        // @ts-expect-error cannot type tokenizer function dynamically
                        tokenizer_1[tokenizerProp] = function () {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i] = arguments[_i];
                            }
                            var ret = tokenizerFunc.apply(tokenizer_1, args);
                            if (ret === false) {
                                ret = prevTokenizer.apply(tokenizer_1, args);
                            }
                            return ret;
                        };
                    };
                    for (var prop in pack.tokenizer) {
                        _loop_3(prop);
                    }
                    opts.tokenizer = tokenizer_1;
                }
                // ==-- Parse Hooks extensions --== //
                if (pack.hooks) {
                    var hooks_1 = _this.defaults.hooks || new _Hooks();
                    var _loop_4 = function (prop) {
                        if (!(prop in hooks_1)) {
                            throw new Error("hook '".concat(prop, "' does not exist"));
                        }
                        if (['options', 'block'].includes(prop)) {
                            return "continue";
                        }
                        var hooksProp = prop;
                        var hooksFunc = pack.hooks[hooksProp];
                        var prevHook = hooks_1[hooksProp];
                        if (_Hooks.passThroughHooks.has(prop)) {
                            // @ts-expect-error cannot type hook function dynamically
                            hooks_1[hooksProp] = function (arg) {
                                if (_this.defaults.async) {
                                    return Promise.resolve(hooksFunc.call(hooks_1, arg)).then(function (ret) {
                                        return prevHook.call(hooks_1, ret);
                                    });
                                }
                                var ret = hooksFunc.call(hooks_1, arg);
                                return prevHook.call(hooks_1, ret);
                            };
                        }
                        else {
                            // @ts-expect-error cannot type hook function dynamically
                            hooks_1[hooksProp] = function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                var ret = hooksFunc.apply(hooks_1, args);
                                if (ret === false) {
                                    ret = prevHook.apply(hooks_1, args);
                                }
                                return ret;
                            };
                        }
                    };
                    for (var prop in pack.hooks) {
                        _loop_4(prop);
                    }
                    opts.hooks = hooks_1;
                }
                // ==-- Parse WalkTokens extensions --== //
                if (pack.walkTokens) {
                    var walkTokens_1 = _this.defaults.walkTokens;
                    var packWalktokens_1 = pack.walkTokens;
                    opts.walkTokens = function (token) {
                        var values = [];
                        values.push(packWalktokens_1.call(this, token));
                        if (walkTokens_1) {
                            values = values.concat(walkTokens_1.call(this, token));
                        }
                        return values;
                    };
                }
                _this.defaults = __assign(__assign({}, _this.defaults), opts);
            });
            return this;
        };
        Marked.prototype.setOptions = function (opt) {
            this.defaults = __assign(__assign({}, this.defaults), opt);
            return this;
        };
        Marked.prototype.lexer = function (src, options) {
            return _Lexer.lex(src, options !== null && options !== void 0 ? options : this.defaults);
        };
        Marked.prototype.parser = function (tokens, options) {
            return _Parser.parse(tokens, options !== null && options !== void 0 ? options : this.defaults);
        };
        Marked.prototype.parseMarkdown = function (blockType) {
            var _this = this;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var parse = function (src, options) {
                var origOpt = __assign({}, options);
                var opt = __assign(__assign({}, _this.defaults), origOpt);
                var throwError = _this.onError(!!opt.silent, !!opt.async);
                // throw error if an extension set async to true but parse was called with async: false
                if (_this.defaults.async === true && origOpt.async === false) {
                    return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
                }
                // throw error in case of non string input
                if (typeof src === 'undefined' || src === null) {
                    return throwError(new Error('marked(): input parameter is undefined or null'));
                }
                if (typeof src !== 'string') {
                    return throwError(new Error('marked(): input parameter is of type '
                        + Object.prototype.toString.call(src) + ', string expected'));
                }
                if (opt.hooks) {
                    opt.hooks.options = opt;
                    opt.hooks.block = blockType;
                }
                var lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);
                var parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);
                if (opt.async) {
                    return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                        .then(function (src) { return lexer(src, opt); })
                        .then(function (tokens) { return opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens; })
                        .then(function (tokens) { return opt.walkTokens ? Promise.all(_this.walkTokens(tokens, opt.walkTokens)).then(function () { return tokens; }) : tokens; })
                        .then(function (tokens) { return parser(tokens, opt); })
                        .then(function (html) { return opt.hooks ? opt.hooks.postprocess(html) : html; })
                        .catch(throwError);
                }
                try {
                    if (opt.hooks) {
                        src = opt.hooks.preprocess(src);
                    }
                    var tokens = lexer(src, opt);
                    if (opt.hooks) {
                        tokens = opt.hooks.processAllTokens(tokens);
                    }
                    if (opt.walkTokens) {
                        _this.walkTokens(tokens, opt.walkTokens);
                    }
                    var html = parser(tokens, opt);
                    if (opt.hooks) {
                        html = opt.hooks.postprocess(html);
                    }
                    return html;
                }
                catch (e) {
                    return throwError(e);
                }
            };
            return parse;
        };
        Marked.prototype.onError = function (silent, async) {
            return function (e) {
                e.message += '\nPlease report this to https://github.com/markedjs/marked.';
                if (silent) {
                    var msg = '<p>An error occurred:</p><pre>'
                        + escape$1(e.message + '', true)
                        + '</pre>';
                    if (async) {
                        return Promise.resolve(msg);
                    }
                    return msg;
                }
                if (async) {
                    return Promise.reject(e);
                }
                throw e;
            };
        };
        return Marked;
    }());

    var markedInstance = new Marked();
    function marked(src, opt) {
        return markedInstance.parse(src, opt);
    }
    /**
     * Sets the default options.
     *
     * @param options Hash of options
     */
    marked.options =
        marked.setOptions = function (options) {
            markedInstance.setOptions(options);
            marked.defaults = markedInstance.defaults;
            changeDefaults(marked.defaults);
            return marked;
        };
    /**
     * Gets the original marked default options.
     */
    marked.getDefaults = _getDefaults;
    marked.defaults = exports.defaults;
    /**
     * Use Extension
     */
    marked.use = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        markedInstance.use.apply(markedInstance, args);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
    };
    /**
     * Run callback for every token
     */
    marked.walkTokens = function (tokens, callback) {
        return markedInstance.walkTokens(tokens, callback);
    };
    /**
     * Compiles markdown to HTML without enclosing `p` tag.
     *
     * @param src String of markdown source to be compiled
     * @param options Hash of options
     * @return String of compiled HTML
     */
    marked.parseInline = markedInstance.parseInline;
    /**
     * Expose
     */
    marked.Parser = _Parser;
    marked.parser = _Parser.parse;
    marked.Renderer = _Renderer;
    marked.TextRenderer = _TextRenderer;
    marked.Lexer = _Lexer;
    marked.lexer = _Lexer.lex;
    marked.Tokenizer = _Tokenizer;
    marked.Hooks = _Hooks;
    marked.parse = marked;
    var options = marked.options;
    var setOptions = marked.setOptions;
    var use = marked.use;
    var walkTokens = marked.walkTokens;
    var parseInline = marked.parseInline;
    var parse = marked;
    var parser = _Parser.parse;
    var lexer = _Lexer.lex;

    exports.Hooks = _Hooks;
    exports.Lexer = _Lexer;
    exports.Marked = Marked;
    exports.Parser = _Parser;
    exports.Renderer = _Renderer;
    exports.TextRenderer = _TextRenderer;
    exports.Tokenizer = _Tokenizer;
    exports.getDefaults = _getDefaults;
    exports.lexer = lexer;
    exports.marked = marked;
    exports.options = options;
    exports.parse = parse;
    exports.parseInline = parseInline;
    exports.parser = parser;
    exports.setOptions = setOptions;
    exports.use = use;
    exports.walkTokens = walkTokens;

}));
//# sourceMappingURL=marked.umd.js.map
